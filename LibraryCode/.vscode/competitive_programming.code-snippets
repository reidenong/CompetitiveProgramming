{
	"Multi test": {
		"scope": "cpp",
		"prefix": "multi_test",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ii = pair<int, int>;",
			"using llp = pair<ll, ll>;",
			"using vi = vector<int>;",
			"using vii = vector<ii>;",
			"using vvi = vector<vi>;",
			"using vll = vector<ll>;",
			"using vvll = vector<vll>;",
			"template<typename T>",
			"using min_heap = priority_queue<T, vector<T>, greater<T>>;",
			"#define pb push_back",
			"#define fi first",
			"#define se second",
			"#define _ <<\" \"<<",
            "",
            "//#ifndef ONLINE_JUDGE",
            "//   #include \"debug/debug.cpp\"",
            "//#else",
            "//   #define debug(...)",
            "//   #define debugArr(...)",
            "//#endif",
			"",
			"void solve() {",
			"    ",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    int TC;",
			"    cin >> TC;",
			"    while (TC--) solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ Template with common includes and macros"
	},
	"Single test": {
		"scope": "cpp",
		"prefix": "single_test",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ii = pair<int, int>;",
			"using llp = pair<ll, ll>;",
			"using vi = vector<int>;",
			"using vii = vector<ii>;",
			"using vvi = vector<vi>;",
			"using vll = vector<ll>;",
			"using vvll = vector<vll>;",
			"template<typename T>",
			"using min_heap = priority_queue<T, vector<T>, greater<T>>;",
			"#define pb push_back",
			"#define fi first",
			"#define se second",
			"#define _ <<\" \"<<",
            "",
            "//#ifndef ONLINE_JUDGE",
            "//   #include \"debug/debug.cpp\"",
            "//#else",
            "//   #define debug(...)",
            "//   #define debugArr(...)",
            "//#endif",
			"",
			"void solve() {",
			"    ",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ Template with common includes and macros"
	},
	"Sparse Table": {
		"scope": "cpp",
		"prefix": "sparse_table",
		"body": [
			"struct sparse_table {",
			"    vector<vector<int>> ST;",
			"    int N, K;",
			"",
			"    // Constructor to build the Sparse Table",
			"    sparse_table(int _N, const vector<int>& a) : N(_N) {",
			"        K = MSB(N);  // Find the maximum power of 2 <= N",
			"        ST.resize(K);",
			"        ST[0] = a;  // Initialize the first row of the Sparse Table with the input array",
			"",
			"        // Build the Sparse Table",
			"        for (int k = 1; k < K; ++k) {",
			"            ST[k].resize(N - (1 << k) + 1);  // Resize the kth row based on range size",
			"            for (int i = 0; i + (1 << k) <= N; ++i) {",
			"                ST[k][i] = gcd(ST[k-1][i], ST[k-1][i + (1 << (k-1))]);",
			"            }",
			"        }",
			"    }",
			"",
			"    // Returns most significant bit of an integer",
			"    inline int MSB(unsigned int x) { return 32 - __builtin_clz(x); }",
			"",
			"    // Query in the range [x, y]",
			"    int query(int x, int y) {",
			"        int k = MSB(y - x + 1) - 1;  // Find the highest power of 2 that fits in the range",
			"        return gcd(ST[k][x], ST[k][y - (1 << k) + 1]);",
			"    }",
			"};",
			""
		],
		"description": "Sparse Table"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "union_find",
		"body": [
			"class UnionFind {",
			"private:",
			"    vector<int> p, rank, setSize;",
			"    int numSets;",
			"public:",
			"    UnionFind(int N) {",
			"        p.assign(N, 0); for (int i = 0; i < N; ++i) p[i] = i;",
			"        rank.assign(N, 0);                           // optional speedup",
			"        setSize.assign(N, 1);                        // optional feature",
			"        numSets = N;                                 // optional feature",
			"    }",
			"",
			"    int find_set(int i) { return (p[i] == i) ? i : (p[i] = find_set(p[i])); }",
			"    bool is_same_set(int i, int j) { return find_set(i) == find_set(j); }",
			"",
			"    int num_disjoint() { return numSets; }      // optional",
			"    int size_of_set(int i) { return setSize[find_set(i)]; } // optional",
			"",
			"    void union_set(int i, int j) {",
			"        if (is_same_set(i, j)) return;                 // i and j are in same set",
			"        int x = find_set(i), y = find_set(j);          // find both rep items",
			"        if (rank[x] > rank[y]) swap(x, y);           // keep x 'shorter' than y",
			"        p[x] = y;                                    // set x under y",
			"        if (rank[x] == rank[y]) ++rank[y];           // optional speedup",
			"        setSize[y] += setSize[x];                    // combine set sizes at y",
			"        --numSets;                                   // a union reduces numSets",
			"    }",
			"};",
			"",
			"// UnionFind ufds (N);          // Create a UFDS with [0..N-1] items",
			"// ufds.find_set(i);            // returns which set i belongs to",
			"// ufds.is_same_set(i, j);      // returns bool 0/1 if i, j are in same set",
			"// ufds.union_set(i, j);        // combines set containing i and set containing j",
			"// ufds.num_disjoint();         // returns int, number of disjoint sets"
		],
		"description": "Union-Find Disjoint Set (UFDS)"
	},
    "Segment Tree": {
        "prefix": "segment_tree",
        "body": [
            "struct node {",
            "\tint s, e;",
            "\tll mn, mx, sum, xr;",
            "\tbool lset;",
            "\tll add_val, set_val;",
            "\tnode *l, *r;",
            "\tnode (int _s, int _e, const vector<int>& A = {}): s(_s), e(_e), mn(0), mx(0), sum(0), xr(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {",
            "\t\tif (A.empty()) return;",
            "\t\tif (s == e) mn = mx = sum = xr = A[s];",
            "\t\telse {",
            "\t\t\tl = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);",
            "\t\t\tcombine();",
            "\t\t}",
            "\t}",
            "\tvoid create_children() {",
            "\t\tif (s == e) return;",
            "\t\tif (l != NULL) return;",
            "\t\tint m = (s+e)>>1;",
            "\t\tl = new node(s, m);",
            "\t\tr = new node(m+1, e);",
            "\t}",
            "\tvoid self_set(ll v) {",
            "\t\tlset = 1;",
            "\t\tmn = mx = set_val = v;",
            "\t\tsum = v * (e-s+1);",
            "\t\txr = v * (e-s+1);",
            "\t\tadd_val = 0;",
            "\t}",
            "\tvoid self_add(ll v) {",
            "\t\tif (lset) { self_set(v + set_val); return; }",
            "\t\tmn += v, mx += v, add_val += v;",
            "\t\tsum += v*(e-s+1);",
            "\t\txr ^= v * (e-s+1);",
            "\t}",
            "\tvoid lazy_propagate() {",
            "\t\tif (s == e) return;",
            "\t\tif (lset) {",
            "\t\t\tl->self_set(set_val), r->self_set(set_val);",
            "\t\t\tlset = set_val = 0;",
            "\t\t}   ",
            "\t\tif (add_val != 0) {",
            "\t\t\tl->self_add(add_val), r->self_add(add_val);",
            "\t\t\tadd_val = 0;",
            "\t\t}",
            "\t}",
            "\tvoid combine() {",
            "\t\tif (l == NULL) return;",
            "\t\tsum = l->sum + r->sum;",
            "\t\tmn = min(l->mn, r->mn);",
            "\t\tmx = max(l->mx, r->mx);",
            "\t\txr = l->xr ^ r->xr;",
            "\t}",
            "\tvoid add(int x, int y, ll v) {",
            "\t\tif (s == x && e == y) { self_add(v); return; }",
            "\t\tint m = (s+e)>>1;",
            "\t\tcreate_children(); lazy_propagate();",
            "\t\tif (x <= m) l->add(x, min(y, m), v);",
            "\t\tif (y > m) r->add(max(x, m+1), y, v);",
            "\t\tcombine();",
            "\t}",
            "\tvoid set(int x, int y, ll v) {",
            "\t\tif (s == x && e == y) { self_set(v); return; }",
            "\t\tint m = (s+e)>>1;",
            "\t\tcreate_children(); lazy_propagate();",
            "\t\tif (x <= m) l->set(x, min(y, m), v);",
            "\t\tif (y > m) r->set(max(x, m+1), y, v);",
            "\t\tcombine();",
            "\t}",
            "\tll range_sum(int x, int y) {",
            "\t\tif (s == x && e == y) return sum;",
            "\t\tif (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_sum(x, y);",
            "\t\tif (x > m) return r->range_sum(x, y);",
            "\t\treturn l->range_sum(x, m) + r->range_sum(m+1, y);",
            "\t}",
            "\tll range_min(int x, int y) {",
            "\t\tif (s == x && e == y) return mn;",
            "\t\tif (l == NULL || lset) return mn;",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_min(x, y);",
            "\t\tif (x > m) return r->range_min(x, y);",
            "\t\treturn min(l->range_min(x, m), r->range_min(m+1, y));",
            "\t}",
            "\tll range_max(int x, int y) {",
            "\t\tif (s == x && e == y) return mx;",
            "\t\tif (l == NULL || lset) return mx;",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_max(x, y);",
            "\t\tif (x > m) return r->range_max(x, y);",
            "\t\treturn max(l->range_max(x, m), r->range_max(m+1, y));",
            "\t}",
            "\tll range_xor(int x, int y) {",
            "\t\tif (s == x && e == y) return xr;",
            "\t\tif (l == NULL || lset) return xr;",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_xor(x, y);",
            "\t\tif (x > m) return r->range_xor(x, y);",
            "\t\treturn l->range_xor(x, m) ^ r->range_xor(m+1, y);",
            "\t}",
            "\t~node() {",
            "\t\tif (l != NULL) delete l;",
            "\t\tif (r != NULL) delete r;",
            "\t}",
            "} *root;",
            "",
            "// root = new node(0, n - 1, A);       // Creates segment tree with range [0, n-1] wiht A",
            "// root = new node(0, 10000000000);    // Creates segment tree with range [0, 10000000000]",
            "// root->add(0, 3, 5);                 // Adds 5 to all elements in range [0, 3]",
            "// root->set(0, 3, 5);                 // Sets all elements in range [0, 3] to 5",
            "// root->range_sum(0, 3);               // Returns sum of elements in range [0, 3]"
        ],
        "description": "Segment Tree"
    },
    "Ordered Set": {
        "prefix": "pbds",
        "body": [
            "// PBDS",
            "// Sorted in ascending order of TYPE_T",
            "#include <bits/extc++.h>",
            "using namespace __gnu_pbds;",
            "typedef tree<TYPE_T, null_type, less<TYPE_T>, rb_tree_tag,",
            "    tree_order_statistics_node_update> ost;",
            "",
            "// Sorted in descending order of TYPE_T",
            "#include <bits/extc++.h>",
            "using namespace __gnu_pbds;",
            "typedef tree<TYPE_T, null_type, greater_equal<TYPE_T>,",
            "    rb_tree_tag, tree_order_statistics_node_update> ost;",
            "",
            "// Usage: TYPE_T -> pair<int, int>",
            "// ost rankings;                                     // Initialization",
            "// rankings.insert(x);                               // Inserting element x into the tree",
            "// int rank = rankings.order_of_key(x);              // Retrieving order of element x",
            "//                                                      x DOES NOT have to be in pbds",
            "// int idx = rankings.order_of_key(target);          // Erasing part 1",
            "// rankings.erase(rankings.find_by_order(idx));      // Erasing part 2",
            "//",
            "// rankings.insert({x, i + 1});                      // pbds with duplicate xs",
            "// int rank = rankings.order_of_key({y, 0})          // get top ranking of all elements of val y",
            ""
        ],
        "description": "Ordered Set"
    },
    "Fenwick Tree": {
        "prefix": "fenwick_tree",
        "body": [
            "class FenwickTree {",
            "public:",
            "    int N;",
            "    vector<int> fw, fw2;",
            "",
            "    FenwickTree(int size) : N(size + 1), fw(N, 0), fw2(N, 0) {}",
            "",
            "    void update(int x, int y, int v) { // inclusive",
            "        for (int tx = x; tx < N; tx += tx & (-tx)) {",
            "            fw[tx] += v;",
            "            fw2[tx] -= v * (x - 1);",
            "        }",
            "        for (int ty = y + 1; ty < N; ty += ty & (-ty)) {",
            "            fw[ty] -= v;",
            "            fw2[ty] += v * y;",
            "        }",
            "    }",
            "",
            "    int sum(int x) {",
            "        int res = 0;",
            "        for (int tx = x; tx; tx -= tx & (-tx))",
            "            res += fw[tx] * x + fw2[tx];",
            "        return res;",
            "    }",
            "",
            "    int range_sum(int x, int y) { // inclusive",
            "        return sum(y) - sum(x - 1);",
            "    }",
            "};",
            "",
            "// FenwickTree ft(n);               // Init a fenwick tree (1-indexed)",
            "// ll rs = ft.range_sum(p, q);      // Do a range_sum from [p, q] inclusive",
            "// ft.update(a, b, c)               // Add c to every element in [a, b] inclusive"
        ],
        "description": "Fenwick Tree"
    },
    "Max flow": {
        "prefix": "maxflow",
        "body": [
            "typedef tuple<int, ll, ll> edge;",
            "const ll INF = 1e18;",
            "/*",
            "Dinic implementation of maxflow.",
            "Time: O(min(mf, V^2)* E)",
            "*/",
            "class max_flow {",
            "    private:",
            "    int V;",
            "    vector<edge> EL;  // EL[i] = {dest node, capacity, flow (+ means u -> dest)}",
            "    vector<vi> AL;    // AL[u] = {EL indices of edges coming from u}",
            "    vi d, last;",
            "    vector<ii> p;",
            "",
            "    bool BFS(int s, int t) {  // find augmenting path",
            "        d.assign(V, -1);",
            "        d[s] = 0;",
            "        queue<int> q({s});",
            "        p.assign(V, {-1, -1});  // record BFS sp tree",
            "        while (!q.empty()) {",
            "            int u = q.front();",
            "            q.pop();",
            "            if (u == t) break;                         // stop as sink t reached",
            "            for (auto &idx : AL[u]) {                  // explore neighbors of u",
            "                auto &[v, cap, flow] = EL[idx];        // stored in EL[idx]",
            "                if ((cap - flow > 0) && (d[v] == -1))  // positive residual edge",
            "                    d[v] = d[u] + 1, q.push(v),",
            "                    p[v] = {u, idx};  // 3 lines in one!",
            "            }",
            "        }",
            "        return d[t] != -1;  // has an augmenting path",
            "    }",
            "",
            "    ll DFS(int u, int t, ll f = INF) {  // traverse from s->t",
            "        if ((u == t) || (f == 0)) return f;",
            "        for (int &i = last[u]; i < (int)AL[u].size(); ++i) {  // from last edge",
            "            auto &[v, cap, flow] = EL[AL[u][i]];",
            "            if (d[v] != d[u] + 1) continue;  // not part of layer graph",
            "            if (ll pushed = DFS(v, t, min(f, cap - flow))) {",
            "                flow += pushed;",
            "                auto &rflow = get<2>(EL[AL[u][i] ^ 1]);  // back edge",
            "                rflow -= pushed;",
            "                return pushed;",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    public:",
            "    max_flow(int initialV) : V(initialV) {",
            "        EL.clear();",
            "        AL.assign(V, vi());",
            "    }",
            "",
            "    void clear() {",
            "        EL.clear();",
            "        AL.assign(V, vi());",
            "        d.clear();",
            "        last.clear();",
            "        p.clear();",
            "    }",
            "",
            "    // if you are adding a bidirectional edge u<->v with weight w into your",
            "    // flow graph, set directed = false (default value is directed = true)",
            "    void add_edge(int u, int v, ll w, bool directed = true) {",
            "        if (u == v) return;                       // safeguard: no self loop",
            "        EL.emplace_back(v, w, 0);                 // u->v, cap w, flow 0",
            "        AL[u].push_back(EL.size() - 1);           // remember this index",
            "        EL.emplace_back(u, directed ? 0 : w, 0);  // back edge",
            "        AL[v].push_back(EL.size() - 1);           // remember this index",
            "    }",
            "",
            "    ll dinic(int s, int t) {",
            "        ll mf = 0;                    // mf stands for max_flow",
            "        while (BFS(s, t)) {           // an O(V^2*E) algorithm",
            "            last.assign(V, 0);        // important speedup",
            "            while (ll f = DFS(s, t))  // exhaust blocking flow",
            "                mf += f;",
            "        }",
            "        return mf;",
            "    }",
            "",
            "    void debug_el() {",
            "        for (int u = 0; u < V; u++) {",
            "            for (auto v : AL[u]) {",
            "                auto [a, b, c] = EL[v];",
            "                cout << u _ a _ b _ c << endl;",
            "            }",
            "        }",
            "    }",
            "",
            "    set<int> get_s_mincut(int s, int t) {",
            "        // dinic(s, t);",
            "        vector<bool> visited(V, false);",
            "        set<int> s_component;",
            "        queue<int> q;",
            "        q.push(s);",
            "        visited[s] = true;",
            "        while (!q.empty()) {",
            "            int u = q.front();",
            "            q.pop();",
            "            s_component.insert(u);",
            "            for (auto &idx : AL[u]) {",
            "                auto &[v, cap, flow] = EL[idx];",
            "                if ((cap - flow > 0) && (!visited[v])) {",
            "                    visited[v] = true;",
            "                    q.push(v);",
            "                }",
            "            }",
            "        }",
            "        return s_component;",
            "    }",
            "};",
            "// max_flow mf(N);                  // Create maxflow object",
            "// mf.add_edge(u, v, w);            // Add a directed edge from u to v with",
            "// capacity w mf.add_edge(u, v, w, false)      // Add a undirected edge from u",
            "// to v with capacity w ll ans = mf.dinic(src, sink);    // Get the maxflow",
            ""
        ],
        "description": "Max flow"
    },
    "Min cost Max flow": {
        "prefix": "mincostmaxflow",
        "body": [
            "typedef tuple<int, ll, ll, ll> edge;",
            "const ll INF = 1e18;",
            "class min_cost_max_flow {",
            "    private:",
            "    int V;",
            "    ll total_cost;",
            "    vector < edge > EL;",
            "    vector < vi > AL;",
            "    vll d;",
            "    vi last,",
            "    vis;",
            "",
            "    bool SPFA(int s, int t) { // SPFA to find augmenting path in residual graph",
            "        d.assign(V, INF);",
            "        d[s] = 0;",
            "        vis[s] = 1;",
            "        queue < int > q({",
            "            s",
            "        });",
            "        while (!q.empty()) {",
            "            int u = q.front();",
            "            q.pop();",
            "            vis[u] = 0;",
            "            for (auto & idx: AL[u]) { // explore neighbors of u",
            "                auto & [v, cap, flow, cost] = EL[idx]; // stored in EL[idx]",
            "                if ((cap - flow > 0) && (d[v] > d[u] + cost)) { // positive residual edge",
            "                    d[v] = d[u] + cost;",
            "                    if (!vis[v]) q.push(v), vis[v] = 1;",
            "                }",
            "            }",
            "        }",
            "        return d[t] != INF; // has an augmenting path",
            "    }",
            "",
            "    ll DFS(int u, int t, ll f = INF) { // traverse from s->t",
            "        if ((u == t) || (f == 0)) return f;",
            "        vis[u] = 1;",
            "        for (int & i = last[u]; i < (int) AL[u].size(); ++i) { // from last edge",
            "            auto & [v, cap, flow, cost] = EL[AL[u][i]];",
            "            if (!vis[v] && d[v] == d[u] + cost) { // in current layer graph",
            "                if (ll pushed = DFS(v, t, min(f, cap - flow))) {",
            "                    total_cost += pushed * cost;",
            "                    flow += pushed;",
            "                    auto & [rv, rcap, rflow, rcost] = EL[AL[u][i] ^ 1]; // back edge",
            "                    rflow -= pushed;",
            "                    vis[u] = 0;",
            "                    return pushed;",
            "                }",
            "            }",
            "        }",
            "        vis[u] = 0;",
            "        return 0;",
            "    }",
            "",
            "    public: ",
            "    min_cost_max_flow(int initialV): V(initialV), total_cost(0) {",
            "        EL.clear();",
            "        AL.assign(V, vi());",
            "        vis.assign(V, 0);",
            "    }",
            "",
            "    // if you are adding a bidirectional edge u<->v with weight w into your",
            "    // flow graph, set directed = false (default value is directed = true)",
            "    void add_edge(int u, int v, ll w, ll c, bool directed = true) {",
            "        if (u == v) return; // safeguard: no self loop",
            "        EL.emplace_back(v, w, 0, c); // u->v, cap w, flow 0, cost c",
            "        AL[u].push_back(EL.size() - 1); // remember this index",
            "        EL.emplace_back(u, 0, 0, -c); // back edge",
            "        AL[v].push_back(EL.size() - 1); // remember this index",
            "        if (!directed) add_edge(v, u, w, c); // add again in reverse",
            "    }",
            "",
            "    pair < ll, ll > mcmf(int s, int t) {",
            "        ll mf = 0; // mf stands for max_flow",
            "        while (SPFA(s, t)) { // an O(V^2*E) algorithm",
            "            last.assign(V, 0); // important speedup",
            "            while (ll f = DFS(s, t)) // exhaust blocking flow",
            "                mf += f;",
            "        }",
            "        return {",
            "            mf,",
            "            total_cost",
            "        };",
            "    }",
            "};",
            "// min_cost_max_flow mf(v);",
            "// mf.add_edge(u, v, w, c);",
            "// llp res = mf.mcmf(s, t);",
            ""
        ],
        "description": "Min cost Max flow"
    }
}
