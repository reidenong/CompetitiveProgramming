{
	"Multi test": {
		"scope": "cpp",
		"prefix": "multi_test",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ii = pair<int, int>;",
			"using lll = pair<ll, ll>;",
			"using vi = vector<int>;",
			"using vii = vector<ii>;",
			"using vvi = vector<vi>;",
			"using vll = vector<ll>;",
			"using vvll = vector<vll>;",
			"template<typename T>",
			"using min_heap = priority_queue<T, vector<T>, greater<T>>;",
			"#define pb push_back",
			"#define fi first",
			"#define se second",
			"#define _ <<\" \"<<",
			"",
			"void solve() {",
			"    ",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    int TC;",
			"    cin >> TC;",
			"    while (TC--) solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ Template with common includes and macros"
	},
	"Single test": {
		"scope": "cpp",
		"prefix": "single_test",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ii = pair<int, int>;",
			"using lll = pair<ll, ll>;",
			"using vi = vector<int>;",
			"using vii = vector<ii>;",
			"using vvi = vector<vi>;",
			"using vll = vector<ll>;",
			"using vvll = vector<vll>;",
			"template<typename T>",
			"using min_heap = priority_queue<T, vector<T>, greater<T>>;",
			"#define pb push_back",
			"#define fi first",
			"#define se second",
			"#define _ <<\" \"<<",
			"",
			"void solve() {",
			"    ",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ Template with common includes and macros"
	},
	"Sparse Table": {
		"scope": "cpp",
		"prefix": "sparse_table",
		"body": [
			"struct sparse_table {",
			"    vector<vector<int>> ST;",
			"    int N, K;",
			"",
			"    // Constructor to build the Sparse Table",
			"    sparse_table(int _N, const vector<int>& a) : N(_N) {",
			"        K = MSB(N);  // Find the maximum power of 2 <= N",
			"        ST.resize(K);",
			"        ST[0] = a;  // Initialize the first row of the Sparse Table with the input array",
			"",
			"        // Build the Sparse Table",
			"        for (int k = 1; k < K; ++k) {",
			"            ST[k].resize(N - (1 << k) + 1);  // Resize the kth row based on range size",
			"            for (int i = 0; i + (1 << k) <= N; ++i) {",
			"                ST[k][i] = gcd(ST[k-1][i], ST[k-1][i + (1 << (k-1))]);",
			"            }",
			"        }",
			"    }",
			"",
			"    // Returns most significant bit of an integer",
			"    inline int MSB(unsigned int x) { return 32 - __builtin_clz(x); }",
			"",
			"    // Query in the range [x, y]",
			"    int query(int x, int y) {",
			"        int k = MSB(y - x + 1) - 1;  // Find the highest power of 2 that fits in the range",
			"        return gcd(ST[k][x], ST[k][y - (1 << k) + 1]);",
			"    }",
			"};",
			""
		],
		"description": "Sparse Table"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "union_find",
		"body": [
			"class UnionFind {",
			"private:",
			"    vector<int> p, rank, setSize;",
			"    int numSets;",
			"public:",
			"    UnionFind(int N) {",
			"        p.assign(N, 0); for (int i = 0; i < N; ++i) p[i] = i;",
			"        rank.assign(N, 0);                           // optional speedup",
			"        setSize.assign(N, 1);                        // optional feature",
			"        numSets = N;                                 // optional feature",
			"    }",
			"",
			"    int find_set(int i) { return (p[i] == i) ? i : (p[i] = find_set(p[i])); }",
			"    bool is_same_set(int i, int j) { return find_set(i) == find_set(j); }",
			"",
			"    int num_disjoint() { return numSets; }      // optional",
			"    int size_of_set(int i) { return setSize[find_set(i)]; } // optional",
			"",
			"    void union_set(int i, int j) {",
			"        if (is_same_set(i, j)) return;                 // i and j are in same set",
			"        int x = find_set(i), y = find_set(j);          // find both rep items",
			"        if (rank[x] > rank[y]) swap(x, y);           // keep x 'shorter' than y",
			"        p[x] = y;                                    // set x under y",
			"        if (rank[x] == rank[y]) ++rank[y];           // optional speedup",
			"        setSize[y] += setSize[x];                    // combine set sizes at y",
			"        --numSets;                                   // a union reduces numSets",
			"    }",
			"};",
			"",
			"// UnionFind ufds (N);          // Create a UFDS with [0..N-1] items",
			"// ufds.find_set(i);            // returns which set i belongs to",
			"// ufds.is_same_set(i, j);      // returns bool 0/1 if i, j are in same set",
			"// ufds.union_set(i, j);        // combines set containing i and set containing j",
			"// ufds.num_disjoint();         // returns int, number of disjoint sets"
		],
		"description": "Union-Find Disjoint Set (UFDS)"
	},
    "Segment Tree": {
        "prefix": "segment_tree",
        "body": [
            "struct node {",
            "\tint s, e;",
            "\tll mn, mx, sum, xr;",
            "\tbool lset;",
            "\tll add_val, set_val;",
            "\tnode *l, *r;",
            "\tnode (int _s, int _e, const vector<int>& A = {}): s(_s), e(_e), mn(0), mx(0), sum(0), xr(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {",
            "\t\tif (A.empty()) return;",
            "\t\tif (s == e) mn = mx = sum = xr = A[s];",
            "\t\telse {",
            "\t\t\tl = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);",
            "\t\t\tcombine();",
            "\t\t}",
            "\t}",
            "\tvoid create_children() {",
            "\t\tif (s == e) return;",
            "\t\tif (l != NULL) return;",
            "\t\tint m = (s+e)>>1;",
            "\t\tl = new node(s, m);",
            "\t\tr = new node(m+1, e);",
            "\t}",
            "\tvoid self_set(ll v) {",
            "\t\tlset = 1;",
            "\t\tmn = mx = set_val = v;",
            "\t\tsum = v * (e-s+1);",
            "\t\txr = v * (e-s+1);",
            "\t\tadd_val = 0;",
            "\t}",
            "\tvoid self_add(ll v) {",
            "\t\tif (lset) { self_set(v + set_val); return; }",
            "\t\tmn += v, mx += v, add_val += v;",
            "\t\tsum += v*(e-s+1);",
            "\t\txr ^= v * (e-s+1);",
            "\t}",
            "\tvoid lazy_propagate() {",
            "\t\tif (s == e) return;",
            "\t\tif (lset) {",
            "\t\t\tl->self_set(set_val), r->self_set(set_val);",
            "\t\t\tlset = set_val = 0;",
            "\t\t}   ",
            "\t\tif (add_val != 0) {",
            "\t\t\tl->self_add(add_val), r->self_add(add_val);",
            "\t\t\tadd_val = 0;",
            "\t\t}",
            "\t}",
            "\tvoid combine() {",
            "\t\tif (l == NULL) return;",
            "\t\tsum = l->sum + r->sum;",
            "\t\tmn = min(l->mn, r->mn);",
            "\t\tmx = max(l->mx, r->mx);",
            "\t\txr = l->xr ^ r->xr;",
            "\t}",
            "\tvoid add(int x, int y, ll v) {",
            "\t\tif (s == x && e == y) { self_add(v); return; }",
            "\t\tint m = (s+e)>>1;",
            "\t\tcreate_children(); lazy_propagate();",
            "\t\tif (x <= m) l->add(x, min(y, m), v);",
            "\t\tif (y > m) r->add(max(x, m+1), y, v);",
            "\t\tcombine();",
            "\t}",
            "\tvoid set(int x, int y, ll v) {",
            "\t\tif (s == x && e == y) { self_set(v); return; }",
            "\t\tint m = (s+e)>>1;",
            "\t\tcreate_children(); lazy_propagate();",
            "\t\tif (x <= m) l->set(x, min(y, m), v);",
            "\t\tif (y > m) r->set(max(x, m+1), y, v);",
            "\t\tcombine();",
            "\t}",
            "\tll range_sum(int x, int y) {",
            "\t\tif (s == x && e == y) return sum;",
            "\t\tif (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_sum(x, y);",
            "\t\tif (x > m) return r->range_sum(x, y);",
            "\t\treturn l->range_sum(x, m) + r->range_sum(m+1, y);",
            "\t}",
            "\tll range_min(int x, int y) {",
            "\t\tif (s == x && e == y) return mn;",
            "\t\tif (l == NULL || lset) return mn;",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_min(x, y);",
            "\t\tif (x > m) return r->range_min(x, y);",
            "\t\treturn min(l->range_min(x, m), r->range_min(m+1, y));",
            "\t}",
            "\tll range_max(int x, int y) {",
            "\t\tif (s == x && e == y) return mx;",
            "\t\tif (l == NULL || lset) return mx;",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_max(x, y);",
            "\t\tif (x > m) return r->range_max(x, y);",
            "\t\treturn max(l->range_max(x, m), r->range_max(m+1, y));",
            "\t}",
            "\tll range_xor(int x, int y) {",
            "\t\tif (s == x && e == y) return xr;",
            "\t\tif (l == NULL || lset) return xr;",
            "\t\tint m = (s+e)>>1;",
            "\t\tlazy_propagate();",
            "\t\tif (y <= m) return l->range_xor(x, y);",
            "\t\tif (x > m) return r->range_xor(x, y);",
            "\t\treturn l->range_xor(x, m) ^ r->range_xor(m+1, y);",
            "\t}",
            "\t~node() {",
            "\t\tif (l != NULL) delete l;",
            "\t\tif (r != NULL) delete r;",
            "\t}",
            "} *root;",
            "",
            "// root = new node(0, n - 1, A);       // Creates segment tree with range [0, n-1] wiht A",
            "// root = new node(0, 10000000000);    // Creates segment tree with range [0, 10000000000]",
            "// root->add(0, 3, 5);                 // Adds 5 to all elements in range [0, 3]",
            "// root->set(0, 3, 5);                 // Sets all elements in range [0, 3] to 5",
            "// root->range_sum(0, 3);               // Returns sum of elements in range [0, 3]"
        ],
        "description": "Segment Tree"
    },
    "Ordered Set": {
        "prefix": "pbds",
        "body": [
            "// PBDS",
            "// Sorted in ascending order of TYPE_T",
            "#include <bits/extc++.h>",
            "using namespace __gnu_pbds;",
            "typedef tree<TYPE_T, null_type, less<TYPE_T>, rb_tree_tag,",
            "    tree_order_statistics_node_update> ost;",
            "",
            "// Sorted in descending order of TYPE_T",
            "#include <bits/extc++.h>",
            "using namespace __gnu_pbds;",
            "typedef tree<TYPE_T, null_type, greater_equal<TYPE_T>,",
            "    rb_tree_tag, tree_order_statistics_node_update> ost;",
            "",
            "// Usage: TYPE_T -> pair<int, int>",
            "// ost rankings;                                     // Initialization",
            "// rankings.insert(x);                               // Inserting element x into the tree",
            "// int rank = rankings.order_of_key(x);              // Retrieving order of element x",
            "//                                                      x DOES NOT have to be in pbds",
            "// int idx = rankings.order_of_key(target);          // Erasing part 1",
            "// rankings.erase(rankings.find_by_order(idx));      // Erasing part 2",
            "//",
            "// rankings.insert({x, i + 1});                      // pbds with duplicate xs",
            "// int rank = rankings.order_of_key({y, 0})          // get top ranking of all elements of val y",
            ""
        ],
        "description": "Ordered Set"
    }
}
